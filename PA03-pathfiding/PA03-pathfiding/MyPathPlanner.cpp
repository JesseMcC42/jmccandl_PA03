#include "MyPathPlanner.h"
#include "MyGame.h"
#include "mathtool/Box.h"
#include <algorithm>

using namespace mathtool;

namespace GMUCS425
{

MyPathPlanner::MyPathPlanner(MyScene * scene, MyAgent * agent)
{
  m_scene=scene;
  m_agent=agent;
}

//TODO: shorten and smooth the path (Bonus: 20 pts)
//To smooth, use Quadratic Bezier curves
void MyPathPlanner::smooth(std::list<Point2d>& path)
{
  //path is both input and output
}

//TODO: (20 pts)
//return true if m_agent collide with a non-movable object
//at a given location
bool MyPathPlanner::collision_detection(const Point2d& pos)
{
  //brute force collision detection

  //methods to use: collide(), getX(), getY(), tranlateTo() in MyAgent
  //get_agents() in MyScene

	list<MyAgent* > agentList = m_scene->get_agents();

	//check all collisions with no moveable objects
	for (list<MyAgent*>::iterator it = agentList.begin(); it != agentList.end(); ++it)
	{
		MyAgent* agent = *it;
		if (agent->is_movable() == 0 || agent->getC() == 'k') {

			//check for collision
			float agentx = agent->getX();
			float agenty = agent->getY();

			mathtool::Box2d box1, box2;
			box1.x = agentx;
			box1.y = agenty;
			box1.width = agent->getSprite()->getWidth(agent->getScale());
			box1.height = agent->getSprite()->getHeight(agent->getScale());

			box2.x = pos[0];
			box2.y = pos[1];
			//Hardcoded values for now
			box2.width = agent->getSprite()->getWidth(agent->getScale());
			box2.height = agent->getSprite()->getHeight(agent->getScale());

			if (box1.intersect(box2)) {
				return true;
			}
		}
	}

  return false;
}

//estimate the cost of travelling from pos1 to pos2
//scaled using the values generated by Perlin noise
float MyPathPlanner::cost(const Point2d& pos1, const Point2d& pos2)
{
	const Uint32* terrain = m_scene->get_terrain();
	int terrain_width = getMyGame()->getScreenWidth();
	int terrain_height = getMyGame()->getScreenHeight();
	Point2d mid((pos1[0] + pos2[0]) / 2, (pos1[1] + pos2[1]) / 2);
	Uint32 watery = terrain[((int)mid[1]) * terrain_width + ((int)mid[0])] & 255;
	float scale = sqrt(sqrt(watery * 1.0f / 255)); //0~1
	return (1 + scale) * (pos1 - pos2).norm();
}

//------------
//TODO: (30 pts)
bool MyGridPathPlanner::build() //build a grid
{
  if(!m_grid.empty()) return false; //build only if the grid is empty

  m_grid=std::vector< std::vector<Node> >( m_height, std::vector<Node>(m_width,Node()) );
  float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;

  //TODO: go through the nodes, and init the data for each node
  for(int i=0;i<m_height;i++)
  {
    for(int j=0;j<m_width;j++)
    {
      Node & n=m_grid[i][j];
      //determine the values of n.pos, n.free and n.neighbors

	  n.pos.set((j * cell_h) + (cell_h / 2), (i * cell_w) + (cell_w / 2));
	  n.visited = false;
	  n.free = !(collision_detection(n.pos));
	  //cerr << "Free at " << n.pos[0] <<  " " << n.pos[1] << " is " << n.free << endl;

	  //cerr << "Master POINT " << n.pos[0] << "   " << n.pos[1] << endl;

	  if ((i - 1 >= 0) && (j - 1 >= 0)) {
		  /*X _ _
			_ o _
			_ _ _
		  */
		  Node& nz = m_grid[i - 1][j-1];
		  Node* np = new Node;
		  np = &nz;

		  n.neighbors.push_front(np);
	  }
	  if (i - 1 >= 0) {
		  /*_ _ _
			X o _
			_ _ _
		  */
		  Node& nz = m_grid[i - 1][j];
		  Node* np = new Node;
		  np = &nz;

		  n.neighbors.push_front(np);
	  }
	  if (i - 1 >= 0 && j + 1 < m_height) {
		  /*_ _ _
			_ o _
			X _ _
		  */
		  Node& nz = m_grid[i - 1][j + 1];
		  Node* np = new Node;
		  np = &nz;

		  n.neighbors.push_front(np);
	  }
	  if (j - 1 >= 0) {
		  /*_ X _
			_ o _
			_ _ _
		  */
		  Node& nz = m_grid[i][j - 1];
		  Node* np = new Node;
		  np = &nz;

		  n.neighbors.push_front(np);
	  }
	  if (j + 1 < m_height) {
		  /*_ _ _
			_ o _
			_ X _
		  */
		  Node& nz = m_grid[i][j + 1];
		  Node* np = new Node;
		  np = &nz;

		  n.neighbors.push_front(np);
	  }
	  if (i + 1 < m_width && j - 1 >= 0) {
		  /*_ _ X
			_ o _
			_ _ _
		  */
		  Node& nz = m_grid[i + 1][j - 1];
		  Node* np = new Node;
		  np = &nz;

		  n.neighbors.push_front(np);
	  }
	  if (i + 1 < m_width) {
		  /*_ _ _
			_ o X
			_ _ _
		  */
		  Node& nz = m_grid[i + 1][j];
		  Node* np = new Node;
		  np = &nz;

		  n.neighbors.push_front(np);
	  }
	  if (i + 1 < m_width && j + 1 < m_height) {
		  /*_ _ _
			_ o _
			_ _ X
		  */
		  Node& nz = m_grid[i + 1][j + 1];
		  Node* np = new Node;
		  np = &nz;

		  n.neighbors.push_front(np);
	  }

    }//end j
  }//end i

  return true;
}

//finding a path using A*
bool MyGridPathPlanner::find_path( const Point2d& start, const Point2d& goal, std::list<Point2d>& path )
{
  //check if the start and goal are valid (i.e., inside the screen)
  if(start[0]<0 || start[1]>=getMyGame()->getScreenWidth()) return false;
  if(goal[0]<0 || goal[1]>=getMyGame()->getScreenWidth()) return false;

  float cell_w=getMyGame()->getScreenWidth()*1.0f/m_width;
  float cell_h=getMyGame()->getScreenHeight()*1.0f/m_height;

  
  Node * S=&m_grid[(int)(start[1]/cell_h)][(int)(start[0]/cell_w)];
  Node * G=&m_grid[(int)(goal[1]/cell_h)][(int)(goal[0]/cell_w)];
  if (!(S->free)) {
	  //cerr << "! Error: Start point makes the agent collide with something" << endl;
	  return false;
  }
  if (!(G->free)) {
	  //cerr << "! Error: Goal point makes the agent collide with something" << endl;
	  return false;
  }
  bool found = false;

  S->g = 0;
  S->f = 0;
  S->visited = true;
  vector<Node*> open, close;
  open.push_back(S);
  close.push_back(S);

  while (!open.empty()) {

	  std::pop_heap(open.begin(), open.end(), comp);
	  Node* best = open.back();
	  open.pop_back();
	  //cerr << "best is node " << best->pos << endl;


	  if (best == G) {
		  while (best != S) {
			  path.push_front(best->pos);
			  best = best->parent;
		  }
		  smooth(path);
		  found = true;
		  break;
	  }

	  for (list<Node*>::iterator it = best->neighbors.begin(); it != best->neighbors.end(); ++it)
	  {
		  Node* neigh = *it;
		  if (!neigh->free) {
			  continue;
		  }
		  else {
			  if (!neigh->visited) {
				  neigh->visited = true;
				  neigh->parent = best;
				  neigh->g = best->g + cost(best->pos, neigh->pos);
				  float h = cost(neigh->pos, G->pos);
				  neigh->f = neigh->g + h;
				  open.push_back(neigh);
				  close.push_back(neigh);
				  push_heap(open.begin(), open.end(), comp);
			  }
			  else {
				  // float cost = neigh->g;
				   //if (neigh->f > cost) {
					 //  neigh->f = cost;
					 //  make_heap(open.begin(), open.end(), comp);
					 //  neigh->parent = best;
				   //}
			  }
		  }
	  }
  }

  while (!close.empty()) {
	  std::pop_heap(close.begin(), close.end());
	  Node* best = close.back();
	  close.pop_back();

	  best->visited = false;
  }


  //cerr << "Path found: "<< found << endl;
  return found;
}

}//end namespace GMUCS425
